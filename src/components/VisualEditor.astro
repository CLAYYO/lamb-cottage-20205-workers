---
// Visual Editor Component for Admin Interface
const { type, sectionId, fieldPath, content, placeholder, className, min, max, step } = Astro.props;

// Generate unique ID for this editor instance
const editorId = `editor-${sectionId}-${fieldPath?.replace(/\./g, '-')}-${Math.random().toString(36).substr(2, 9)}`;
---

{type === 'image' && (
  <div class="image-editor-container">
    {content ? (
      <img 
        id={editorId}
        src={content} 
        alt="Editable image"
        class={`editable-image ${className || ''}`}
        data-editable="true"
        data-section={sectionId}
        data-field={fieldPath}
        style="max-width: 100%; height: auto; min-height: 200px; border: 2px dashed #d1d5db; border-radius: 8px; cursor: pointer;"
      />
    ) : (
      <div 
        id={editorId}
        class={`image-placeholder ${className || ''}`}
        data-editable="true"
        data-section={sectionId}
        data-field={fieldPath}
        style="min-height: 200px; border: 2px dashed #d1d5db; border-radius: 8px; display: flex; align-items: center; justify-content: center; background: #f9fafb; cursor: pointer; color: #6b7280;"
      >
        <div style="text-align: center;">
          <div style="font-size: 48px; margin-bottom: 8px;">ðŸ“·</div>
          <div>Click to upload image</div>
          <div style="font-size: 12px; margin-top: 4px;">Recommended size: 1920x600px</div>
        </div>
      </div>
    )}
  </div>
)}

{type === 'text' && (
  <input 
    id={editorId}
    type="text" 
    value={content || ''}
    placeholder={placeholder || ''}
    class={`editable-text ${className || ''}`}
    data-editable="true"
    data-section={sectionId}
    data-field={fieldPath}
    style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;"
  />
)}

{type === 'textarea' && (
  <textarea 
    id={editorId}
    placeholder={placeholder || ''}
    class={`editable-textarea ${className || ''}`}
    data-editable="true"
    data-section={sectionId}
    data-field={fieldPath}
    style="width: 100%; min-height: 100px; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; resize: vertical;"
  >{content || ''}</textarea>
)}

{type === 'rich' && (
  <div 
    id={editorId}
    class={`editable-rich ${className || ''}`}
    data-editable="true"
    data-section={sectionId}
    data-field={fieldPath}
    style="min-height: 120px; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; background: white;"
  >
    {content || placeholder || 'Click to edit content...'}
  </div>
)}

{type === 'range' && (
  <input 
    id={editorId}
    type="range" 
    value={content || 0.4}
    min={min || 0}
    max={max || 1}
    step={step || 0.1}
    class={`editable-range ${className || ''}`}
    data-editable="true"
    data-section={sectionId}
    data-field={fieldPath}
    style="width: 100%;"
  />
)}

<script>
  // Extend window interface for TypeScript
  declare global {
    interface Window {
      securityManager: any;
      VisualEditor: typeof VisualEditor;
      visualEditor: VisualEditor;
    }
  }
  
  // Function to get SecurityManager instance (should be available globally)
  function getSecurityManager() {
    if (window.securityManager) {
      return window.securityManager;
    }
    
    // SecurityManager should be available via global script
    console.error('SecurityManager not available on window object');
    return null;
  }
  
  class VisualEditor {
    constructor() {
      this.init();
    }

    init() {
      console.log('VisualEditor initializing...');
      // Add edit buttons to editable elements
      const editableElements = document.querySelectorAll('[data-editable]');
      console.log(`Found ${editableElements.length} editable elements:`, editableElements);
      
      editableElements.forEach((element, index) => {
        console.log(`Adding edit button to element ${index + 1}:`, {
          id: element.id,
          tagName: element.tagName,
          dataSection: element.getAttribute('data-section'),
          dataField: element.getAttribute('data-field')
        });
        this.addEditButton(element as HTMLElement);
      });
      
      console.log('VisualEditor initialization complete');
    }

    addEditButton(element: HTMLElement) {
      // Check if button already exists
      if (element.querySelector('.edit-btn')) {
        console.log('Edit button already exists for element:', element.id);
        return;
      }
      
      const editBtn = document.createElement('button');
      editBtn.className = 'edit-btn';
      editBtn.innerHTML = 'âœï¸';
      editBtn.title = 'Edit this content';
      
      editBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.startEdit(element.id);
      };

      // Position the button
      element.style.position = 'relative';
      element.appendChild(editBtn);
      
      console.log('Edit button added to element:', element.id, 'Button visible:', editBtn.offsetWidth > 0);
    }

    startEdit(editorId: string) {
      const editor = document.getElementById(editorId);
      if (!editor) return;

      const isImage = editor.tagName === 'IMG' || editor.classList.contains('image-placeholder');
      
      if (isImage) {
        this.editImage(editorId);
      } else {
        this.editText(editorId);
      }
    }

    editText(editorId: string) {
      const editor = document.getElementById(editorId);
      if (!editor) return;

      const originalContent = editor.textContent || editor.innerHTML;
      editor.dataset.original = originalContent;

      // Create textarea for editing
      const textarea = document.createElement('textarea');
      textarea.value = originalContent;
      textarea.className = 'edit-textarea';
      
      // Replace content with textarea
      editor.innerHTML = '';
      editor.appendChild(textarea);
      
      // Add save/cancel buttons
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'edit-buttons';
      
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save';
      saveBtn.className = 'save-btn';
      saveBtn.onclick = () => this.saveContent(editorId);
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'cancel-btn';
      cancelBtn.onclick = () => this.cancelEdit(editorId);
      
      buttonContainer.appendChild(saveBtn);
      buttonContainer.appendChild(cancelBtn);
      editor.appendChild(buttonContainer);
      
      textarea.focus();
    }

    editImage(editorId: string) {
      const editor = document.getElementById(editorId);
      if (!editor) return;

      // For image placeholders, directly trigger file upload
      if (editor.classList.contains('image-placeholder')) {
        this.changeImage(editorId);
        return;
      }

      // Create image editor overlay for existing images
      const overlay = document.createElement('div');
      overlay.className = 'image-edit-overlay';
      
      const changeBtn = document.createElement('button');
      changeBtn.textContent = 'Change Image';
      changeBtn.className = 'change-image-btn';
      changeBtn.onclick = () => this.changeImage(editorId);
      
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'delete-image-btn';
      deleteBtn.onclick = () => this.deleteImage(editorId);
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'cancel-btn';
      cancelBtn.onclick = () => this.cancelImageEdit(editorId);
      
      overlay.appendChild(changeBtn);
      overlay.appendChild(deleteBtn);
      overlay.appendChild(cancelBtn);
      
      editor.style.position = 'relative';
      editor.appendChild(overlay);
    }

    async saveContent(editorId: string) {
      if (!editorId) return;
      const editor = document.getElementById(editorId);
      if (!editor) return;

      let content = '';
      const sectionId = editor.dataset.section;
      const fieldPath = editor.dataset.field;

      if (!sectionId || !fieldPath) {
        this.showError('Missing section or field information');
        return;
      }

      // Handle different editor types
      if (editor.tagName === 'IMG') {
        // For images, save the src attribute
        content = (editor as HTMLImageElement).src || '';
      } else if (editor.classList.contains('image-placeholder')) {
        // For image placeholders, save empty string (no image uploaded yet)
        content = '';
      } else {
        // For text editors, get content from textarea
        const textarea = editor.querySelector('textarea');
        if (!textarea) return;
        content = textarea.value;
      }

      try {
        const response = await fetch('/api/content/update-field', {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            section: sectionId,
            field: fieldPath,
            content: content
          })
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(errorData.error || `Request failed: ${response.status}`);
        }
        
        const result = await response.json();
        this.showMessage('Content saved successfully!', 'success');
        
        // Update original data
        editor.dataset.original = content;
        
        // Restore display
        editor.innerHTML = content;
        this.addEditButton(editor);
        
        // Update the display if it's an image
        if (editor.tagName === 'IMG') {
          (editor as HTMLImageElement).src = content;
        }
        
      } catch (error) {
        console.error('Save error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        this.showError('Failed to save content: ' + errorMessage);
      }
    }

    cancelEdit(editorId: string) {
      if (!editorId) return;
      const editor = document.getElementById(editorId);
      if (!editor) return;

      const originalContent = editor.dataset.original;
      if (originalContent) {
        editor.innerHTML = originalContent;
        this.addEditButton(editor);
      }
    }

    cancelImageEdit(editorId: string) {
      if (!editorId) return;
      const editor = document.getElementById(editorId);
      if (!editor) return;

      const overlay = editor.querySelector('.image-edit-overlay');
      if (overlay) {
        overlay.remove();
      }
    }

    changeImage(editorId: string) {
      if (!editorId) return;
      
      // Store the editor ID for later use
      (window as any).currentEditingImageId = editorId;
      
      // Open image manager in a new window/tab
        const imageManagerUrl = `/admin/images?editorId=${editorId}`;
        const imageManagerWindow = window.open(imageManagerUrl, 'imageManager', 'width=1200,height=800,scrollbars=yes,resizable=yes');
        
        // Store the editor ID globally for fallback
        (window as any).currentEditingImageId = editorId;
      
      if (!imageManagerWindow) {
        // Fallback: redirect to image manager
        window.location.href = imageManagerUrl + '?returnTo=' + encodeURIComponent(window.location.pathname) + '&editorId=' + encodeURIComponent(editorId);
        return;
      }
      
      // Store reference to this for use in message handler
      const self = this;
      
      // Listen for image selection from the image manager
      const messageHandler = (event: MessageEvent) => {
        if (event.origin !== window.location.origin) return;
        
        if (event.data && event.data.type === 'imageSelected' && event.data.editorId === editorId) {
          const imageUrl = event.data.imageUrl;
          
          // Update the editor with the selected image
          const editor = document.getElementById(editorId);
          if (editor) {
            let newEditor = editor;
            if (editor.tagName === 'IMG') {
              (editor as HTMLImageElement).src = imageUrl;
            } else if (editor.classList.contains('image-placeholder')) {
              // Replace placeholder with actual image
              const img = document.createElement('img');
              img.id = editorId;
              img.src = imageUrl;
              img.alt = 'Editable image';
              img.className = editor.className.replace('image-placeholder', 'editable-image');
              img.setAttribute('data-editable', 'true');
              img.setAttribute('data-section', editor.dataset.section || '');
              img.setAttribute('data-field', editor.dataset.field || '');
              img.style.cssText = 'max-width: 100%; height: auto; min-height: 200px; border: 2px dashed #d1d5db; border-radius: 8px; cursor: pointer;';
              editor.parentNode?.replaceChild(img, editor);
              self.addEditButton(img);
              newEditor = img;
            }
            
            // Save the image URL to the content
            self.saveImageContent(newEditor.id, imageUrl);
          }
          
          // Close the image manager window
          imageManagerWindow.close();
          
          // Remove the event listener
          window.removeEventListener('message', messageHandler);
          
          self.cancelImageEdit(editorId);
        }
      };
        
        // Add the event listener
        window.addEventListener('message', messageHandler);
      }
    }

    async saveImageContent(editorId: string, imageUrl: string) {
      if (!editorId) return;
      const editor = document.getElementById(editorId);
      if (!editor) return;

      const sectionId = editor.dataset.section;
      const fieldPath = editor.dataset.field;

      if (!sectionId || !fieldPath) {
        this.showError('Missing section or field information');
        return;
      }

      try {
        const response = await fetch('/api/content/update-field', {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            section: sectionId,
            field: fieldPath,
            content: imageUrl
          })
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(errorData.error || `Request failed: ${response.status}`);
        }
        
        const result = await response.json();
        this.showMessage('Image saved successfully!', 'success');
        
      } catch (error) {
        console.error('Save error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        this.showError('Failed to save image: ' + errorMessage);
      }
    }

    deleteImage(editorId: string) {
      if (!editorId) return;
      if (confirm('Are you sure you want to delete this image?')) {
        const editor = document.getElementById(editorId);
        if (editor && editor.tagName === 'IMG') {
          (editor as HTMLImageElement).src = '';
          this.saveImageContent(editorId, '');
          this.cancelImageEdit(editorId);
        }
      }
    }
    
    showMessage(message: string, type: string) {
      const notification = document.createElement('div');
      notification.className = `fixed top-4 right-4 px-4 py-2 rounded-md text-white z-50 ${
        type === 'success' ? 'bg-green-500' : 'bg-red-500'
      }`;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }
    
    showError(message: string) {
      this.showMessage(message, 'error');
    }
  }
  
  // Expose VisualEditor class globally for testing and external access
  (window as any).VisualEditor = VisualEditor;
  
  // Initialize when DOM is loaded and store instance globally
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      (window as any).visualEditor = new VisualEditor();
    });
  } else {
    (window as any).visualEditor = new VisualEditor();
  }
</script>

<style>
  .edit-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    cursor: pointer;
    font-size: 12px;
    z-index: 1000;
    opacity: 1;
    transition: opacity 0.2s;
    display: block !important;
    visibility: visible !important;
  }
  
  [data-editable]:hover .edit-btn {
    opacity: 1;
  }
  
  [data-editable] {
    position: relative;
  }
  
  .edit-textarea {
    width: 100%;
    min-height: 100px;
    padding: 8px;
    border: 2px solid #3b82f6;
    border-radius: 4px;
    font-family: inherit;
    font-size: inherit;
    resize: vertical;
  }
  
  .edit-buttons {
    margin-top: 8px;
    display: flex;
    gap: 8px;
  }
  
  .save-btn, .cancel-btn, .change-image-btn, .delete-image-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  
  .save-btn {
    background: #10b981;
    color: white;
  }
  
  .cancel-btn {
    background: #6b7280;
    color: white;
  }
  
  .change-image-btn {
    background: #3b82f6;
    color: white;
  }
  
  .delete-image-btn {
    background: #ef4444;
    color: white;
  }
  
  .image-edit-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    z-index: 20;
  }
</style>